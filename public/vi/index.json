[
{
	"uri": "/vi/1-setup/",
	"title": "Account and Environment Setup",
	"tags": [],
	"description": "",
	"content": "Chọn Region Chúng ta chỉ sử dụng một region trong suốt buổi workshop và trong bài workshop này, chúng ta sẽ sử dụng ap-southeast-1 (Asia Pacific - Singapore).\nCác bạn có thể chọn region khác tùy thuộc vào địa điểm bạn thực hiện bài workshop này để nhận được sự phản hồi nhanh chóng hơn.\nKhởi tạo AWS Cloud9 IDE AWS Cloud9 là một môi trường phát triển tích hợp (IDE) dựa trên cloud cho phép cac bạn viết, chạy, debug code trên trình duyệt. Nó bao gồm code editor, debugger và terminal. Cloud9 được đóng gói sẵn trong các công cụ cần thiết cho các ngôn ngữ lập trình phổ biến và AWS Command Line Interface (CLI) được cài đặt sẵn nên bạn không cần phải cài đặt file, cấu hình cho thiết bị mà các bạn đang dùng.\nMôi trường Cloud9 của bạn sẽ có quyền truy cập vào cùng resource AWS như là người dùng mà bạn đã đăng nhập vào AWS Management Console.\nSetup Cloud9 Sau khi đăng nhập vào AWS Management Console với account của bạn, hãy vào Cloud9 console. Click vào nút Create environment.\nTiếp theo, các bạn nhập cost-optimization-workshop cho giá trị của Name, các bạn chọn tạo mới EC2 ở phần Environment type với Instance type là t2.micro. Còn lại sẽ để mặc định, cuối cùng click vào nút Create.\nSẽ mất vài phút để đợi Cloud9 Environment được tạo xong.\nSetup Cloud9 IDE Khi Cloud9 IDE được tạo thành công, các bạn click vào nút Open như trên màn hình.\nVà chúng giao diện của Cloud9 IDE được mở ra, hãy tắt tab Welcome, tắt terminal được khởi tạo sẵn và mở tab terminal mới.\nBây giờ bạn có thể chạy các lệnh AWS CLI trên terminal của Cloud9 IDE mà ko cần phải cài đặt lại. Hãy luôn mở AWS Cloud9 IDE trên trình duyệt trong suốt buổi workshop này.\nTiếp theo các bạn cần xác thực lại account hiện tại đang truy cập vào Cloud9 IDE này cách dán câu lệnh sau vào terminal vừa được tạo aws sts get-caller-indentity và nhấn Enter. Các bạn sẽ thấy output như hình dưới đây.\nResize Cloud9 Environment Trước khi bắt đầu đi vào thực hiện, các bạn cần resize lại storage hiện tại bằng cách chạy câu lệnh dưới đây ở Cloud9 terminal. Đầu tiên chúng ta cần download file resize.sh từ đường dẫn dưới đây bằng lệnh curl.\ncurl \u0026#39;https://static.us-east-1.prod.workshops.aws/public/9cac7f06-a925-4a51-99f6-38ec4fb8707c/static/code/resize.sh\u0026#39; -o resize.sh Khi download thành công, chúng ta sẽ nhận được như hình dưới đây.\nBây giờ chúng ta sẽ chạy file script resize.sh bằng câu lệnh bash.\nbash resize.sh 20 Và chúng ta sẽ nhận được kết quả như hình sau khi resize thành công.\nĐể đọc và hiểu thêm về resize.sh script, các bạn hãy truy cập tài liệu tài đây Cloud9 documentation\n"
},
{
	"uri": "/vi/4-traffic/4.1-deploy/",
	"title": "Deploy",
	"tags": [],
	"description": "",
	"content": "Đầu tiên, ở Cloud9 workspace của các bạn, di chuyển vào environment.\ncd ~/environment/ Dùng câu lệnh dưới đây để download code artifact.\ncurl \u0026#39;https://static.us-east-1.prod.workshops.aws/public/9cac7f06-a925-4a51-99f6-38ec4fb8707c/static/code/traffic-throttle.zip\u0026#39; -o traffic-throttle.zip \u0026amp;\u0026amp; unzip traffic-throttle.zip Sau khi download, các bạn sẽ thấy một thư mục mới có tên là traffic-throttle.\nDi chuyển vào thư mục này.\ncd traffic-throttle Tiếp theo, các bạn sẽ package và deploy SAM application bằng câu lệnh:\nsam build \u0026amp;\u0026amp; sam deploy --guided Stack Name: traffic-throttle AWS Region: ap-southeast-1 Confirm changes before deploy [y/N]: default Allow SAM CLI IAM role creation [Y/n]: default Disable rollback: default Save arguments to configuration file [Y/n]: default SAM configuration file [samconfig.toml]: default SAM configuration environment [default]: default Sau khi deploy thành công, chúng ta sẽ nhận được dòng xác nhận như dưới đây.\nSuccessfully created/updated stack - traffic-throttle in ap-southeast-1 "
},
{
	"uri": "/vi/2-powertuning/2.1-deploytuning/",
	"title": "Deploy The Lambda Power Tuning Tool",
	"tags": [],
	"description": "",
	"content": "Lambda Power Tuning Tool được lưu trữ ở Serverless Application Repository. SAR cho phép customers nhanh chóng publish và deploy ứng dụng Serverless. Customer có thể cấu hình quyền của SAR để cho phép truy cập vào các account cụ thể, account trong một tổ chức hoặc quyền truy cập công khai để có khả năng khởi chạy ứng dụng.\nKhởi chạy Lambda Power Tuning Tool Đầu tiên, các bạn hãy truy cập vào Serverless Application Repository. Ở thanh bên trái, chọn Available applications. Trên phần tìm kiếm ứng dụng, các bạn hãy nhập AWS Lambda Power Tuning ở mục Public applications và chọn vào Show apps that create custom IAM roles or resource policies. Sau đó chọn ứng dụng aws-lambda-power-tuning.\nỞ trang Review, configure and deploy, chúng ta để mặc định các thông số, chọn vào I acknowledge that this app creates custom IAM roles và click vào nút Deploy ở cuối trang.\nChờ vài phút sau khi ứng dụng được deploy, chúng ta sang CloudFormation Console để kiểm tra xem ứng dụng đã cài đặt thành công hay chưa.\n"
},
{
	"uri": "/vi/3-graviton2/3.1-deploytuning/",
	"title": "Deploy The Lambda Power Tuning Tool",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ bắt đầu bằng cách tạo Lambda function được viết bằng Python và được deploy trên x86 architecture. Sau đó, chúng ta sẽ chuyển đổi hàm này sang Arm-based Graviton2 architecture. Chúng ta sẽ sử dụng Lambda Power Tuning tool từ Module 1.\nLambda Power Tuning Tool được lưu trữ trên Serverless Application Repository. Serverless Application Repository (SAR) cho phép customer nhanh chóng publish và deploy serverless applications. Customer có thể định cấu hình SAR permission để cho phép truy cập vào các account cụ thể, account trong một tổ chức hoặc quyền truy cập công khai để có khả năng khởi chạy ứng dụng. Truy cập để biết thêm nhiều thông tin về Serverless Application Repository ở đây\nHãy xem lại ở bước Deploy Lambda Power Tuning Tool ở Module 1 để biết thêm chi tiết về cách deploy Lambda Power Tuning Tool.\n"
},
{
	"uri": "/vi/",
	"title": "Tối ưu hóa cho Serverless (Performance and Cost)",
	"tags": [],
	"description": "",
	"content": "Tối ưu hóa cho Serverless (Performance and Cost) Giới thiệu Trong bài workshop này, chúng ta sẽ đi tìm hiểu các cách tối ưu hóa performance và cost của Serverless.\nĐể xem thêm nhiều Serverless Architecture Best Practices, các bạn hãy truy cập vào Serverless Application Lens để tìm từ AWS Well Architected Framework.\nBài workshop này sẽ gồm các phần xoay quanh một mục đích chung là cost reduction. Tất cả các module đều được làm độc lập vì vậy các bạn có thể hoàn thành từng phần riêng biệt.\nCác module được sắp xếp từ thứ tự dễ thực hiện nhất và có 3 mục chính trong bài workshop này.\nPower Tuning và Log Tuning là những best practice thường bị bỏ qua và việc triển khai các phương pháp này không ảnh hưởng đến hoạt động của ứng dụng của bạn. Trong bài workshop này, các bạn sẽ đi vào thực hiện phương pháp Power Tuning.\nGravition2, Direct Integration, Provisioned Concurrency và Code Tuning là các phương pháp tiếp cận dựa trên configuration cần một vài code touches và operation overhead. Trong bài workshop này, các bạn sẽ đi vào thực hiện phương pháp Gravition2.\nTraffic Throttling và Asynchronous Workflows cần sự thay đổi thiết kế tổng thể đối với ứng dụng Serverless của bạn. Và chúng ta sẽ đi thực hiện Traffic Throttling.\nNhững gì bạn sẽ học được Trong suốt bài workshop này, bạn sẽ được tìm hiểu một số kĩ thuật thực hành tốt nhất để tối ưu hóa workload của Serverless nhằm giảm chi phí và tăng hiệu suất. Bài workshop này tập trung vào AWS Lambda bên cạnh đó các services khác được sử dụng bao gồm:\nAmazon SQS Amazon API Gateway Amazon DynamoDB AWS Step Functions AWS AppConfig Những kiến thức, kĩ năng cần có để hoàn thành bài workshop này Kiến thức cơ bản về các services AWS Serverless cần thiết bao gồm AWS Lambda, API Gateway, SQS và DynamoDB. Bạn phải làm quen với AWS Console, AWS CLI, AWS IAM và CloudFormation.\nKiến thức cơ bản về Linux và Python cũng là một lợi thế.\nNội dung Giới thiệu Solution Deployment Trường hợp cho Cacheable Dọn dẹp tài nguyên "
},
{
	"uri": "/vi/2-powertuning/2.2-deploytest/",
	"title": "Deploy Test Lambda Function",
	"tags": [],
	"description": "",
	"content": "Bây giờ bạn đã cài đặt xong power tuning tool, bước tiếp theo là chạy AWS Lambda function dựa trên tool đó. Trong phần này, bạn sẽ deploy Lambda function để kiểm tra việc sử dụng Power Tuning Tool. Function này tốn nhiều bộ nhớ, sử dụng matrices.\nDeploy the function Hãy đảm bảo rằng bạn đang deploy function này ở cùng region mà bạn đã cài đặt Lambda Power Tuning Tool\nĐầu tiên, bạn hãy vào AWS Lambda Console, nhìn vào thanh bên trái và chọn Functions. Click vào nút Create function.\nỞ trang Create function, hãy chọn Author from scratch, đặt tên cho Function name là lambda-power-tuning-test. Chọn Runtime là Python 3.8 và Architecture là x86_64, còn lại sẽ để mặc định. Cuối cùng, click vào nút Create function ở cuối trang.\nChờ giây lát, khi function được tạo ra, các bạn sẽ được điều hướng đến function đó. Ở mục Function overview, click vào Layers, nó sẽ chuyển ta xuống cuối trang ở phần Layers.\nClick vào nút Add a layer ở góc phải.\nỞ trang Add layer, các bạn chọn AWS layers cho phần mục Layer source. Ở phần AWS layers, hãy chọn AWSLambda-Python38-SciPy1x và Version mới nhất ở thời điểm bạn tạo. Cuối cùng, click vào nút Add ở cuối trang.\nChờ giây lát khi layer mới được thêm vào Lambda function, chúng ta xuống dưới mục Code và copy đoạn code dưới đây và paste vào file lambda_function.py.\nimport json\rimport numpy as np\rfrom scipy.spatial import ConvexHull\rdef lambda_handler(event, context):\rms = 100\rprint(\u0026#34;Printing from version on 10302020 - size of matrix\u0026#34;, ms,\u0026#34;x\u0026#34;,ms)\rprint(\u0026#34;\\nFilling the matrix with random integers below 100\\n\u0026#34;)\rmatrix_a = np.random.randint(100, size=(ms, ms))\rprint(matrix_a)\rprint(\u0026#34;random matrix_b =\u0026#34;)\rmatrix_b = np.random.randint(100, size=(ms, ms))\rprint(matrix_b)\rprint(\u0026#34;matrix_a * matrix_b = \u0026#34;)\rprint(matrix_a.dot(matrix_b))\rnum_points = 10\rprint(num_points, \u0026#34;random points:\u0026#34;)\rpoints = np.random.rand(num_points, 2)\rfor i, point in enumerate(points):\rprint(i, \u0026#39;-\u0026gt;\u0026#39;, point)\rhull = ConvexHull(points)\rprint(\u0026#34;The smallest convex set containing all\u0026#34;,\rnum_points, \u0026#34;points has\u0026#34;, len(hull.simplices),\r\u0026#34;sides,\\nconnecting points:\u0026#34;)\rfor simplex in hull.simplices:\rprint(simplex[0], \u0026#39;\u0026lt;-\u0026gt;\u0026#39;, simplex[1])\rreturn {\r\u0026#39;statusCode\u0026#39;: 200,\r\u0026#39;headers\u0026#39;: {\r\u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;,\r\u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;\r},\r\u0026#39;body\u0026#39;: \u0026#39;\u0026#39;,\r\u0026#34;isBase64Encoded\u0026#34;: False\r} Python Lambda function này sẽ generate ra random data và perform operation của nó. Nó được dùng cho experimentation và testing. Bây giờ hãy cùng xem vai trò của từng đoạn code:\n1. Import Statements: Đoạn code bắt đầu bằng cách import những thư viện cần thiết:\njson: Thư viện này cho phép chúng ta sử dụng và làm việc với JSON data. numpy (np alias): NumPy là thư viện cho những phép tính số trong Python ConvexHull from scipy.spatial: Thư viện này cung cấp các function cho computing convex hulls, một khái niệm cơ bản trong computional geometry. 2. lambda_handler Function: Đây là function chính được thực thi khi Lambda function được trigger.\nms được set giá trị 100, đại diện cho size của matrix được generate. Nó in ra size của matrix. 3. Generating and Printing Random Matrices:\nHai random matrices, matrix_a và matrix_b, của size ms x ms được generate với giá trị số nguyên random dưới 100. Các matrice này được in ra. Kết quả của matrix_a và matrix_b được tính toán bằng method dot và được in ra. 4. Generating and Printing Random Points:\nnum_points được set giá trị 10, đại diện cho số lượng random points được generate. Nó generate num_points random 2D points (points) và in ra chúng. 5. Computing Convex Hull:\nNó tính toán convex hull của các random points được generate bằng cách sử dụng function ConvexHull từ scipy.spatial. Nó in ra số lượng sides của convex set nhỏ nhất chứa tất cả các points và các connections giữa các points (simplices). 6. Return Statement:\nNó trả về một JSON response với status code là 200 và các headers bổ sung. Body của response là empty (\u0026rsquo;\u0026rsquo;). Tóm lại, Lambda function này được dùng cho testing và experimentation cùng với random data geration và convex hull computation. Khi được trigger, nó generate random matrices, randome points, và tính toán convex hull của các points, cung cấp insights về các mối quan hệ hình học giữa các points.\nSau khi paste đoạn code trên vào file lambda_function.py, hãy click vào nút Deploy\nSau khi deploy thành công, click vào mục Configuration, sau đó click vào nút Edit.\nỞ trang Edit basic settings, chúng ta sẽ thay đổi giá trị của Memory thành 3008, Time out là 5 min 0 sec. Sau đó click vào nút Save ở cuối trang.\nTest function Bây giờ chúng ta hãy vào phần Test của Lambda function. Đặt tên cho Event name là test, để mặc định ở những chổ còn lại và click vào nút Test.\nSau khi test thành công, chúng ta sẽ nhận được như hình dưới đây.\nLên lại đầu trang Lambda function, chúng ta sẽ thấy Function ARN và copy nó.\n"
},
{
	"uri": "/vi/3-graviton2/3.2-deploytest/",
	"title": "Deploy the base function",
	"tags": [],
	"description": "",
	"content": "Trong phần này, bạn sẽ deploy Lambda function có chi phí tính toán cao được viết bằng Python 3.9. Function xác định số lượng số nguyên tố trong khoảng từ 0 đến 10 triệu. Function này được thực hiện ở bài blog Lambda Graviton2.\nHãy đảm bảo bạn đang deploy function cùng region với Lambda Power Tuning Tool.\nDeploy x86 Lambda Function Đầu tiên, hãy vào Lambda Console. Ở thanh bên trái, chọn Functions, sau đó click vào nút Create function.\nỞ trang Create function, hãy chọn Author from scratch. Đặt tên cho Function name là lambda-base-function. Chọn Python 3.9 ở Runtime và Architecture là x86_64. Cuối cùng là click vào nút Create function.\nCopy đoạn code dưới đây.\nimport json\rimport math\rimport platform\rimport timeit\rdef primes_up_to(n):\rprimes = []\rfor i in range(2, n+1):\ris_prime = True\rsqrt_i = math.isqrt(i)\rfor p in primes:\rif p \u0026gt; sqrt_i:\rbreak\rif i % p == 0:\ris_prime = False\rbreak\rif is_prime:\rprimes.append(i)\rreturn primes\rdef lambda_handler(event, context):\rstart_time = timeit.default_timer()\rN = 1000000\rprimes = primes_up_to(N)\rstop_time = timeit.default_timer()\relapsed_time = stop_time - start_time\rresponse = {\r\u0026#39;machine\u0026#39;: platform.machine(),\r\u0026#39;elapsed\u0026#39;: elapsed_time,\r\u0026#39;message\u0026#39;: \u0026#39;There are {} prime numbers \u0026lt;= {}\u0026#39;.format(len(primes), N)\r}\rreturn {\r\u0026#39;statusCode\u0026#39;: 200,\r\u0026#39;body\u0026#39;: json.dumps(response)\r} Python Lambda function này tính toán các số nguyên tố lên đến giới hạn N được chỉ định và đo thời gian cần thiết để thực hiện phép tính này. Cùng đi qua từng phần của đoạn code:\nImport Statements: json: Thư viện này cho phép làm việc với JSON data. math: Thư viện này cho phép làm việc với các hàm toán học. platform: Thư viện này cho phép truy cập vào các thông tin về hệ điều hành, máy chủ và phiên bản Python. timeit: Thư viện này cho phép đo thời gian thực thi của một đoạn code. primes_up_to function: Function này tính toán các số nguyên tố lên đến giới hạn n. Nó khởi tạo danh sách trống primes để chứa các số nguyên tốt. Nó lặp qua các số từ 2 đến n. Với mỗi số i, nó kiểm tra xem có phải số nguyên tố hay không bằng cách chia nó cho tất cả các số nguyên tố tìm được trước đó cho đén căn bậc hai của i. Nếu i chia hết cho bất kì số nguyên tố nào trong số này thì đó không phải là số nguyên tố và vòng lặp liên tục. Ngược lại, i được coi là số nguyên tố và được thêm vào danh sách primes. Function này sẽ trả về danh sách các số nguyên tố được tìm thấy. lambda_handler function: Đây là Lambda function chính nó sẽ thực thi khi Lambda được trigger. Nó sẽ đo thời gian bắt đầu thực thi của function bằng cách sử dụng timeit.default_timer(). Nó set giá trị của N là 1000000, dùng để tìm tất cả các số nguyên tố lên đến 1000000. Nó gọi primes_up_to function để tìm tất cả các số nguyên tố lên đến N. Nó sẽ đo thời gian kết thúc thực thi của function bằng cách sử dụng timeit.default_timer(). Nó gồm response JSON bao gồm: machine: loại máy hoặc môi trường hosting elapsed: thời gian thực thi của function message: số lượng số nguyên tố được tìm thấy Return Statement: Nó trả về response JSON với statusCode là 200 và body là response JSON. body của response bao gồm dữ liệu JSON được generate trong response dictionary. Tóm lại, Lambda function này tính toán các số nguyên tố lên đến giới hạn N (trong trường hợp này N=1000000), đo thời gian thực thi phép tính toán và cung cấp thông tin về máy chủ. Đây là một ví dụ đơn giản sử dụng Lambda để biểu diễn tác vụ tính toán và báo cáo kết quả.\nSau khi copy đoạn code trên, vào trang lambda-base-function, paste đoạn code đó vào file lambda_function.py.\nChuyển sang mục Configuration, ở General configuration, click vào nút Edit.\nỞ trang Edit basic settings, các bạn set Timeout thành 3 min 0 sec. Sau đó click vào nút Save.\nTiếp theo, quay trở lại mục Code, chúng ta sẽ tạo test cho Lambda function bằng cách click vào nút Test.\nKhi cửa sổ Configure test event mở ra, đặt tên cho Event name là test1. Những mục còn lại, các bạn để mặc định. Click vào nút Save.\nBây giờ, chúng ta click nút Test và thấy kết quả như hình bên dưới với status code là 200.\nThu nhập Metrics từ Lambda Power Tunning Tool Đầu tiên, copy ARN của Lambda function lambda-base-function.\nHãy giữ trình duyệt của Lambda function này vì chúng ta sẽ tiếp tục dùng nó.\nCác bạn mở trình duyệt mới và truy cập vào AWS Step Functions console. Chúng ta sẽ thấy state machine mà chúng ta tạo ở phần trước. Click chọn state machine đó.\nterraform-20210621150844388600000001 = vpc(subnet, lambda, security group, role,)\nCopy đoạn script dưới đây.\n{\r\u0026#34;lambdaARN\u0026#34;: \u0026#34;YOUR LAMBDA ARN HERE\u0026#34;,\r\u0026#34;powerValues\u0026#34;: [128, 256, 512, 1024, 2048, 3008],\r\u0026#34;num\u0026#34;: 10,\r\u0026#34;payload\u0026#34;: \u0026#34;{}\u0026#34;,\r\u0026#34;parallelInvocation\u0026#34;: true,\r\u0026#34;strategy\u0026#34;: \u0026#34;cost\u0026#34;\r} Chọn Start execution để bắt đầu phân tích function chúng ta vừa tạo. Cửa sổ Start execution mở ra, chúng ta paste đoạn script trên vào Input, hãy nhớ thay giá trị của LambdaARN bằng ARN chúng ta copy từ Lambda function trên. Sau đó click vào nút Start execution.\nChờ giây lát khi chúng ta thấy Excution status là Succeeded. Và lấy URL ở output tương tự như ở phần Analysis\nTiếp theo, các bạn hãy chọn phần Execution input and output. Các bạn sẽ thấy ở phần output có URL ở visualization field. Copy URL đó.\nHãy mở trình duyệt mới (Google, CocCoc, Microsoft Edge, etc) và paste URL đó vào. Các bạn sẽ nhận được như hình dưới đây.\nHãy giữ nguyên trình duyệt này để dùng so sánh hiệu suất của function khác ở bước tiếp theo.\n"
},
{
	"uri": "/vi/4-traffic/4.2-norate/",
	"title": "No Rate Limiting",
	"tags": [],
	"description": "",
	"content": "\nTrong phần trước, các bạn đã deploy hai architecture đơn giản riêng biệt. Architecture đầu tiên không implement rate limiting nào. Client gọi trực tiếp Lambda function để insert payload vào bảng DynamoDB. Vì không imlement rate limiting nên DynamoDB sẽ vượt quá công suất được cung cấp khi chịu tải nặng.\nChúng ta sẽ khám phá code trong Cloud9 một lát. Đầu tiên, hãy vào thư mục traffic-throttle \u0026gt; standard \u0026gt; standard_lambda_ddb và mở file app.py. Nhìn vào sẽ thấy Lambda function dùng để insert payload vào bảng DynamoDB.\nỞ phần sau, chúng ta sẽ sử dụng công cụ load generating để minh họa cách architecture này hoạt động dưới tải.\n"
},
{
	"uri": "/vi/2-powertuning/",
	"title": "Power Tuning",
	"tags": [],
	"description": "",
	"content": "Mục tiêu của bài workshop này là tìm hiểu và hiểu rõ hơn về các AWS Lambda functions trong quá trình development. Hiểu cụ thể cách cấu hình các resource cho một Lambda function nhất định để tối ưu hóa chi phí và hiệu suất. Mục đích là để hiểu thời gian thực thi sẽ thay đổi như thế nào bằng cách tăng hoặc giảm bộ nhớ được phân bổ cho các Lambda function.\nBài workshop này sẽ dùng Lambda Power Tuning Project được tạo ra bởi Alex Casalboni. Project nằm ở Serverless Application Repository.\nChi tiết về loại tool này Nó giúp bạn điều chỉnh việc phân bổ bộ nhớ cho phù hợp với bất kì Lambda function nào được triển khai trong account của bạn.\nAWS Lambda Power Tuning Tool là một state machine được hổ trợ bởi AWS Step Functions, giúp bạn tối ưu hóa các Lambda functions về chi phí và/hoặc hiệu suất bằng cách dựa vào dữ liệu.\nState machine được thiết kế để dễ deploy và thực thi nhanh chóng. Ngoài ra, đó là ngôn ngữ agnostic nên bạn có thể tối ưu hóa mọi Lambda function trong account của bạn.\nBạn cung cấp ARN của Lambda function làm input và state machine sẽ gọi function đó với nhiều cấu hình khác nhau (từ 128MB đến 3GB). Sau đó, nó sẽ phân tích tất cả các logs khi thực thi và đưa ra đề xuất về cấu hình nguồn tốt nhất để giảm thiếu chi phí và/hoặc tối đa hóa hiệu suất.\n"
},
{
	"uri": "/vi/2-powertuning/2.3-analysis/",
	"title": "Analysis",
	"tags": [],
	"description": "",
	"content": "Bây giờ bạn đã deploy power tuning tool và test Lambda function. Đây là lúc tìm ra memory size tốt nhất cho function này. Power Tuning Tool sẽ chạy function của chúng ta với nhiều memory size khác nhau để giúp xác định cấu hình nào tốt nhất cho chi phí và hiệu năng. Trong phần này, chúng ta sẽ đi qua các bước để phân tích cấu hình của function chúng ta.\nĐầu tiên, các bạn hãy vào Step Function console. Ở thanh bên trái, hãy chọn State machines. Ở đây chúng ta sẽ thấy state machine mà các bạn đã tạo ra ở phần trước. Click vào state machine đó.\nCopy đoạn script dưới đây.\n{\r\u0026#34;lambdaARN\u0026#34;: \u0026#34;YOUR LAMBDA ARN HERE\u0026#34;,\r\u0026#34;powerValues\u0026#34;: [128, 256, 512, 1024, 2048, 3008],\r\u0026#34;num\u0026#34;: 10,\r\u0026#34;payload\u0026#34;: \u0026#34;{}\u0026#34;,\r\u0026#34;parallelInvocation\u0026#34;: true,\r\u0026#34;strategy\u0026#34;: \u0026#34;cost\u0026#34;\r} Ở trang powerTuningStateMachine vừa mở ra, các bạn hãy click vào Start execution ở góc phải trên cùng.\nKhi trang Start execution mở ra, hãy paste đoạn script ở trên vào phần Input - optional và thay thế YOUR LAMBDA ARN HERE bằng ARN của Lambda function mà các bạn đã tạo ra ở phần trước. Sau đó, click vào nút Start execution ở cuối trang.\nChờ đến khi execution hoàn thành, các bạn sẽ thấy Execution status với giá trị là Succeeded.\nTiếp theo, các bạn hãy chọn phần Execution input and output. Các bạn sẽ thấy ở phần output có URL ở visualization field. Copy URL đó.\nHãy mở trình duyệt mới (Google, CocCoc, Microsoft Edge, etc) và paste URL đó vào. Các bạn sẽ nhận được như hình dưới đây.\nTừ bảng phân tích ở trên, các bạn có thể kết luận rằng để tối ưu hóa function với chi phí thấp nhất, cấu hình memory 512MB sẽ là tốt nhất. Để tối ưu hóa function về hiệu suất (tức là thời gian thực thi ngắn nhất), cấu hình memory 512MB sẽ là tốt nhất.\nNếu function ban đầu được cấu hình là 128MB thì việc tăng memory lên 512MB có thể giảm chi phí và cải thiện hiệu suất. Việc tăng memory lên trên 2048MB không làm giảm thời gian thực thi và do đó chỉ dẫn đến chi phí cao. Điều này cho thấy tầm quan trọng của việc tối ưu hóa các Lambda function trong môi trường của bạn.\nWorkshop này minh họa sự cân bằng giữa chi phí và hiệu suất khi tạo và thực thi các Lambda function. Lambda Tuning có thể được sử dụng để đánh giá các yêu cầu cho resource và phân tích cost profile. Ứng dụng Power Tuning sẽ được sử dụng trong module Gravition để phân tích hiệu suất của function trên các compute architectures khác.\n"
},
{
	"uri": "/vi/3-graviton2/3.3-deploygra/",
	"title": "Deploy Graviton2 Function",
	"tags": [],
	"description": "",
	"content": "Trong phần này, bạn sẽ sửa đổi Lambda function từ phần trước để deploy architecture dựa trên Graviton2 Arm-based thay vì x86 architecture\nDeploy Graviton2 arm_64 Lambda Function Đầu tiên chúng ta cần vào lại Console của Lambda Function được tạo ở bước trước.\nCuộn xuống ở phần Runtime settings, click vào nút Edit.\nỞ trang Edit runtime settings, chúng ta chọn architecture arm64. Sau đó click vào nút Save.\nBây giờ, click vào nút Test và chúng ta nhận được output như hình.\nThu nhập Metrics từ Lambda Power Tunning Tool Copy ARN của Lambda function lambda-base-function. Quay lại bước trước, chúng ta thay thế lambdaARN trong đoạn script bằng ARN vừa copy của Lambda function này. Sau đó click vào nút Start execution ở cuối trang.\nSau khi lấy URL của output, chúng ta sẽ được như hình.\nSo sánh các số liệu hiệu suất của mỗi function Để so sánh kết quả giữa hai architecture, click vào nút Compare ở trong trình duyệt.\nĐiều thông tin bao gồm Name for function và Visualization URL of function.\nBây giờ, bạn có thể xem kết quả so sánh của cả Invocation Time và Cost giữ x86 và arm64 architecture function. Quan sát arm64 function thể hiện tốt hơn cả về Cost và Invocation Time trong trường hợp này.\nBạn có thể làm theo các bước này để so sánh giá/hiệu suất của Lambda function code của riêng bạn. Tùy thuộc vào workload, có thể chỉ thấy sự cải thiện về giá chứ không thấy sự cải thiện về hiệu suất. Trong trường hợp này, các bạn nên tận dụng các instrumentation và observability như AWS X-Ray để xác định bottleneck. Trong nhiều trường hợp, các dependencies của function yêu cầu update chứ không phải chính code của function.\nTrước khi migrate functions của bạn sang Graviton2\nĐể biết thêm hướng dẫn về cách truyển workload hiện có sang Graviton2, hãy truy cập vào AWS Graviton Githuv Repo khi chuyển workload sang trang Amazon EC2 instance dựa trên AWS Graviton2. Hãy luôn kiểm tra trước khi thực hiện thay đổi production workload!\n"
},
{
	"uri": "/vi/3-graviton2/",
	"title": "Graviton2",
	"tags": [],
	"description": "",
	"content": "\nVào tháng 9 năm 2021, AWS đã thông báo AWS Lambda functions sẽ có tùy chọn được cung cấp bởi AWS Graviton2 Processor, một Arm-based architecture do AWS thiết kế và xây dựng.\nLambda functions được hỗ trợ bởi AWS Graviton2 processor có thể cải thiện hiệu suất/giá tốt hơn tới 34% so với x86. Graviton2 functions sử dụng Arm-based processor architecture được thiết kế để mang lại hiệu suất tốt hơn tới 19% cùng chi phí thấp hơn 20% cho nhiều Serverless workloads khác nhau, chẳng hạn như web và mobile backend, data và media processing. Với độ trễ thấp hơn và hiệu suất tốt hơn, các functions được hỗ trợ bởi AWS Graviton2 processor rất lí tưởng để cung cấp năng lượng cho các ứng dụng Serverless quan trọng.\nNhững cải tiến về giá/hiệu suất sẽ thay đổi tùy theo thời gian chạy và source code. Trong module này, chúng ta sẽ tìm hiểu testing sample code với cả hai architecture và hoàn thành phân tích về giá/hiệu suất.\nĐể tìm hiểu thêm về Graviton2 trên AWS, hãy truy cập vào Getting Started on Graviton Git Repo.\nHãy xem bài blog này để tìm hiểu thêm về cách migrate các Lambda functions của bạn sang Graviton2.\n"
},
{
	"uri": "/vi/4-traffic/4.3-rate/",
	"title": "Rate Limiting",
	"tags": [],
	"description": "",
	"content": "Architecture thứ hai được deploy có rate limiting được implement bằng SQS Queue. Trong architecture này, client sẽ gọi Lambda function đầu tiên có payload. Lambda function này insert record vào SQS Queue. Lambda function thứ hai sẽ đọc một số lượng message cố định trên mỗi nhóm từ queue và insert chúng vào bảng DynamoDB. Vì chúng ta đang kiểm soát số lượng message trong nhóm nên thông lượng do DynamoDB cung cấp (WCU \u0026amp; RCU) sẽ không bị vượt quá.\nClient sẽ request đến Lambda function. Lambda function này insert payload vào SQS Queue. Lambda function thứ hai đọc một lượng messages cố định trong một nhóm và insert những items đó vào bảng DynamoDB.\nReview architecture đã deploy Trong Cloud9 workspace, các bạn vào thư mục traffic-throttle \u0026gt; ratelimit folder. Ở đây, các bạn sẽ thấy 2 thư mục có code của Lambda function: sqs_insert_lambda và sqs_read_ddb_insert_lambda.\nNhìn vào file app.py trong thư mục sqs_insert_lambda. Các bạn sẽ thấy function gửi payload vào SQS Queue.\nLambda function thứ 2, trong thư mục sqs_read_ddb_insert_lambda, mở file app.py, các bạn sẽ thấy function xử lí messages trong batch, gửi payload vào bảng DynamoDB.\nỞ phần sau, chúng ta sẽ sủ dụng load generating tool để minh họa cách architecture này hoạt động dưới tải.\n"
},
{
	"uri": "/vi/4-traffic/4.4-generating/",
	"title": "Generating Load",
	"tags": [],
	"description": "",
	"content": "Test Client - Artillery Installation Để generate load trên hai architecture mới được deploy, các bạn sẽ sử dụng công cụ distributed load testing Artillery.io. Các bước sau đây sẽ hướng dẫn bạn cách cài đặt và sử dụng công cụ này trong Cloud9 environment.\nĐầu tiên, các bạn sẽ kiểm tra npm được cài đặt hay chưa bằng câu lệnh npm -v trên terminal của Cloud9. Nếu các bạn chưa cài đặt thì hãy cài đặt cả node và npm. Hãy làm theo hướng dẫn để cài đặt node và npm cho hệ thống của bạn.\nnpm -v Nếu npm đã được cài đặt, các bạn sẽ thấy output như hình.\nTiếp theo, chạy câu lệnh dưới đây để cài đặt Artillery. Hãy đọc Artillery.io documentation để tìm hiểu thêm về công cụ này.\nnpm install -g artillery Khi cài đặt thành công, chúng ta sẽ thấy như hình bên dưới.\nCài đặt Artillery Engine Lambda bằng câu lệnh dưới đây. Tài liệu tham khảo Artillery Engine Lambda.\nnpm install -g artillery-engine-lambda@1.0.18 Khi cài đặt thành công, chúng ta sẽ thấy như hình bên dưới.\nGenerate Traffic Có một file artillery loadTest đã được đưa vào thư mục traffic-throttle được giải nén trước đó. Các bạn có thể kiểm tra bằng cách điều hướng đến thư mục traffic-throttle/artillery và mở file LambdaTest.yaml.\nCác bạn sẽ cần đến tên của hai Lambda functions đã được deploy ở lúc đầu phàn này. Để lấy được, hãy vào Lambda Console.\nĐầu tiên, hãy cùng test flow của non-rate limited. Copy tên function bắt đầu bằng traffic-throttle-StandardLambdaDDB. Sau đó, mở lại file LambdaTest.yaml ở Cloud9 workspace, paste tên function đó vào key target. Đổi region thành region mà Lambda function đó được deploy. Lưu lại file.\nBắt đầu test bằng cách chạy câu lệnh dưới đây ở Cloud9 terminal. Hãy chắc chắn bạn đang ở đường dẫn traffic-throttle/artillery. Sẽ mất khoảng 3 đến 4 phút để hoàn thành.\nartillery run lambdaTest.yaml Bây giờ hãy test flow của Throttle. Copy tên function bắt đầu bằng traffic-throttle-SQSInsertLambda và paste vào key target. Chạy lại câu lẹnh dưới đây để test.\nartillery run lambdaTest.yaml "
},
{
	"uri": "/vi/4-traffic/",
	"title": "Traffic Throttling",
	"tags": [],
	"description": "",
	"content": "Tổng quát Trong phần này, các bạn sẽ deploy hai architecture để mô tả throttling ở level DynamoDB resource.\nỞ architecture đầu tiên, client sẽ tương tác với lambda function. Lambda function này trực tiếp insert payload vào bảng DynamoDB. Khi lưu lượng truy cập vào Lambda function tăng lên, DynamoDB sẽ tiêu thụ nhiều hơn kahr năng được cung cấp. Các bạn sẽ thấy một số throttled requests ở DynamoDB level.\nArchitecture thứ hai triển khai throttling qua SQS Queue. Có hai Lambda function trong architecture này. Lambda functions đầu tiên sẽ insert vào SQS Queue. Lambda function thứ hai truy xuất một loạt messages cố định và insert chúng vào DynamoDB. Lambda function thứ hai control số lượng messages sẽ được xử lí (throttle). Cái này cho phép chúng ta control các resource mà DynamoDB (WCY và RCU) tiêu thụ và do đó tránh được throttling.\n"
},
{
	"uri": "/vi/4-traffic/4.5-analysis/",
	"title": "Analysis",
	"tags": [],
	"description": "",
	"content": "DynamoDB Metrics Bây giờ, chúng ta chạy load test và có thể kiểm tra write metrics của DynamoDB CloudWatch để quan sát sự khác biệt giữa hai solutions.\nĐầu tiên hãy vào DynamoDB Console để xem hai tables. Tale Message được sử dụng bởi function traffic-throttle-StandardLambdaDDB và table RateLimitMessage được sử dụng bởi rate limiting traffic-throttle-SQSReadDDBInsertLambda (tức là function consume messages từ SQS Queue).\nClick vào table Message và xuống phần Overview ở mục Table capacity metrics được show bởi CloudWatch graphs. Ở biểu đồ Write usage (average units/second) click vào menu và chọn view in metrics để xem trong CloudWatch.\nỞ biểu đồ trong CloudWatch, các bạn sẽ thấy consumed capacity units vượt quá mức cung cấp. Cái này sẽ xảy ra vì không có rate limiting nào được áp dụng cho Lambda function này. Kết quả là việc auto sclaing của DynamoDB đã tăng Write Capacity Units (WCU) từ 12 lên 37.\nBây giờ hãy lặp lại quy trình tương tự để xem biểu đồ của DynamoDB table RateLimitMessage. Bạn sẽ thấy rằng consumed capacity không vượt quá giới hạn dung lượng được cung cấp. Do đó khả năng auto scaling do DynamoDB thực hiện ít biết động hơn khi chỉ tăng từ 12 lên 16.\nTổng kết Giải pháp Rate Limiting là một giải pháp rẻ hơn, đặc biệt khi lưu lượng truy cập vào giờ cao điểm không liên lục và xảy ra hầu như hàng giờ. Rate Limiting hạn chế DynamoDB mở rộng quy mô resource để bù đắp chi phí của Lambda function bổ sung và SQS Queue. Pattern này cũng mang lại modularity, tách rời người tạo tin nhắn khỏi người tiêu dụng tin nhắn.\nGiải pháp này không giảm chi phí cho tất cả các loại request patterns.\n"
},
{
	"uri": "/vi/5-clean/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Lambda Power Tuning Tool Các bạn hãy vào CloudFormation Console. Tìm kiếm từ khóa aws-lambda-power-tuning và chọn stack đó. Sau đó click vào nút Delete.\nTest Lambda Function Các bạn hãy vào Lambda Console. Chọn function mà các bạn tạo trước đó. Sau đó click vào nút Actions và chọn Delete.\nSAM Ở terminal của Cloud9, hãy di chuyển vào thư mục traffic-throttle.\ncd ~/environment/traffic-throttle/ Sau đó xóa bằng câu lệnh dưới đây.\nsam delete --stack-name traffic-throttle --no-prompts Sẽ mất vài phút để xóa. Các bạn có thể xem quá trình xóa ở CloudFormation Console.\n"
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]