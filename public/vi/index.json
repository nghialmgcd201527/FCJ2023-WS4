[
{
	"uri": "/vi/1-setup/",
	"title": "Account and Environment Setup",
	"tags": [],
	"description": "",
	"content": "Chọn Region Chúng ta chỉ sử dụng một region trong suốt buổi workshop và trong bài workshop này, chúng ta sẽ sử dụng ap-southeast-1 (Asia Pacific - Singapore).\nCác bạn có thể chọn region khác tùy thuộc vào địa điểm bạn thực hiện bài workshop này để nhận được sự phản hồi nhanh chóng hơn.\nKhởi tạo AWS Cloud9 IDE AWS Cloud9 là một môi trường phát triển tích hợp (IDE) dựa trên cloud cho phép cac bạn viết, chạy, debug code trên trình duyệt. Nó bao gồm code editor, debugger và terminal. Cloud9 được đóng gói sẵn trong các công cụ cần thiết cho các ngôn ngữ lập trình phổ biến và AWS Command Line Interface (CLI) được cài đặt sẵn nên bạn không cần phải cài đặt file, cấu hình cho thiết bị mà các bạn đang dùng.\nMôi trường Cloud9 của bạn sẽ có quyền truy cập vào cùng resource AWS như là người dùng mà bạn đã đăng nhập vào AWS Management Console.\nSetup Cloud9 Cách làm này sẽ thực hiện việc tạo ra các services để phục vụ cho bài workshop này. Các services này sẽ được tạo ra bằng cách sử dụng AWS CloudFormation. AWS CloudFormation là một dịch vụ của AWS giúp chúng ta tự động hóa việc triển khai các tài nguyên của AWS. Chúng ta sẽ sử dụng AWS CloudFormation để tạo ra CloudFront distribution, Amazon S3 Bucket và IAM Role.\nHãy cùng deploy template này như dưới đây:\nKhởi chạy CloudFormation template này. Ở trong trang này, lướt xuống phần Capabilities, chọn vào ô \u0026ldquo;I acknowledge that AWS CloudFormation might create IAM resources with custom names.\u0026rdquo; và nhấn vào nút Create stack như hình bên dưới Sẽ mất vài phút để stack này được tạo ra thành công. Bạn sẽ thấy tương tự như hình bên dưới. Tiếp tục, hãy tải file html (sẽ phục vụ cho Origin của chúng ta). Tải ở đây. Lưu trữ nó ở máy của chúng ta và giải né. File này sẽ bao gồm file html mà chúng ta sẽ sử dụng cho Origin content. Bây giờ chúng ta hãy di chuyển sang trang S3 bucket. Chúng ta sẽ thấy S3 bucket được tạo ra bởi CloudFormation template của chúng ta. Click vào S3 bucket đó, click vào nút Upload. Click vào nút Add files, chọn file html đã tải ở trên và tải file đó lên S3 bucket của chúng ta. Vậy là chúng ta vừa hoàn thành xong việc cài đặt môi trường. Bây giờ chúng ta có thể bắt đầu thực hành với bài workshop của chúng ta.\nChúng ta có thể deploy resource của chúng ta theo cách khác đó là CDK Project. Chúng ta sẽ dùng CloudShell ở AWS Region us-east-1. Tải file CDK project dưới dạng zip ở đường dẫn này. Và đọc tài liệu hỗ trợ cho deploy CDK project ở đây.\nHãy cùng xem lại tất cả resources được deploy để hiểu hơn về bài workshop của chúng ta. Rồi hãy cùng bắt tay vào thực hành.\n"
},
{
	"uri": "/vi/",
	"title": "Tối ưu hóa cho Serverless (Performance and Cost)",
	"tags": [],
	"description": "",
	"content": "Tối ưu hóa cho Serverless (Performance and Cost) Giới thiệu Trong bài workshop này, chúng ta sẽ đi tìm hiểu các cách tối ưu hóa performance và cost của Serverless.\nĐể xem thêm nhiều Serverless Architecture Best Practices, các bạn hãy truy cập vào Serverless Application Lens để tìm từ AWS Well Architected Framework.\nBài workshop này sẽ gồm các phần xoay quanh một mục đích chung là cost reduction. Tất cả các module đều được làm độc lập vì vậy các bạn có thể hoàn thành từng phần riêng biệt.\nCác module được sắp xếp từ thứ tự dễ thực hiện nhất và có 3 mục chính trong bài workshop này.\nPower Tuning và Log Tuning là những best practice thường bị bỏ qua và việc triển khai các phương pháp này không ảnh hưởng đến hoạt động của ứng dụng của bạn. Trong bài workshop này, các bạn sẽ đi vào thực hiện phương pháp Power Tuning.\nGravition2, Direct Integration, Provisioned Concurrency và Code Tuning là các phương pháp tiếp cận dựa trên configuration cần một vài code touches và operation overhead. Trong bài workshop này, các bạn sẽ đi vào thực hiện phương pháp Gravition2.\nTraffic Throttling và Asynchronous Workflows cần sự thay đổi thiết kế tổng thể đối với ứng dụng Serverless của bạn. Và chúng ta sẽ đi thực hiện Traffic Throttling.\nNhững gì bạn sẽ học được Trong suốt bài workshop này, bạn sẽ được tìm hiểu một số kĩ thuật thực hành tốt nhất để tối ưu hóa workload của Serverless nhằm giảm chi phí và tăng hiệu suất. Bài workshop này tập trung vào AWS Lambda bên cạnh đó các services khác được sử dụng bao gồm:\nAmazon SQS Amazon API Gateway Amazon DynamoDB AWS Step Functions AWS AppConfig Những kiến thức, kĩ năng cần có để hoàn thành bài workshop này Kiến thức cơ bản về các services AWS Serverless cần thiết bao gồm AWS Lambda, API Gateway, SQS và DynamoDB. Bạn phải làm quen với AWS Console, AWS CLI, AWS IAM và CloudFormation.\nKiến thức cơ bản về Linux và Python cũng là một lợi thế.\nNội dung Giới thiệu Solution Deployment Trường hợp cho Cacheable Dọn dẹp tài nguyên "
},
{
	"uri": "/vi/3-cache/3.1-urired/",
	"title": "URI based Redirects",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ bắt đầu với một trường hợp đơn giản có thể dễ dàng hiểu được bằng cách sử dụng Lambda@Edge vì trường hợp này có thể được cached, do đó sẽ tốt nhất khi xử lí bằng các Lambda@Edge.\nTrường hợp này thường được sử dụng để redirect users vì một lí do nào đó khi request URI mà admin không muốn users đó xem hoặc URI có thể không khả dụng nữa. Ví dụ, user có thể gửi request đến /uri-main.html, tuy nhiên, admin muốn tất cả request đó được thực hiện bởi /uri-redirect.html\nStep 1: Tạo ra Cache Behavior cho trường hợp này Để thực hiện được trường hợp này, đầu tiên bạn sẽ tạo ra một cache behavior cụ thể. Các bước sau dây sẽ hướng dẫn để làm trường hợp này.\nĐi đến CloudFront console. Các bạn sẽ thấy Distribution được tạo ra bởi CloudFormation template, nó sẽ được xác định bởi Edge Redirect Workshop Distribution như ở mục Description. Chọn Distribution đó sau đó chọn vào mục Behaviors. Click vào nút Create Behavior. Ở mục Path pattern, chúng ta nhập /uri-main.html, ở dưới là phần Origin and origin groups, chúng ta chọn myS3Origin. Ở phần Viewer protocol policy, chúng ta chọn Redirect HTTP to HTTPS. Những mục còn lại chúng ta sẽ để mặc định và click vào nút Create behavior ở cuối trang. Step 2: Tạo Lambda@Edge function và publish new version Bước này sẽ là quá trình tạo ra function của chúng ta cùng với version của nó. Các Lambda@Edge functions cần được CloudFront Distribution refer dựa vào version ARN của chúng chứ không phải main function ARN của chúng.\nĐi vào Lambda Console ỏ AWS Region us-east-1, click vào nút Create function. Ở trang Create function, đặt tên cho function của chúng ta là edge-uri-redirect, chọn Python 3.9 cho phần Runtime. Ở phía dưới, chúng ta mở mục Change default execution role rồi chọn Use an existing role, chúng ta chọn edge-redirect-lambda-role (đây là role được tạo từ CloudFormation template). Cuối cùng là click vào nút Create function. Khi function được tạo xong, chúng ta ở trang chính của function đó. Ở phần Code ở dưới, chúng ta copy đoạn code dưới đây và paste vào phần Code source. import json\rdef lambda_handler(event, context):\rget_uri = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;uri\u0026#39;]\rprint(get_uri)\rif (get_uri == \u0026#39;/uri-main.html\u0026#39;):\rresponse = {\r\u0026#39;status\u0026#39;: \u0026#39;301\u0026#39;,\r\u0026#39;statusDescription\u0026#39;: \u0026#39;Permanent Redirect\u0026#39;,\r\u0026#39;headers\u0026#39;: {\r\u0026#39;location\u0026#39;: [{\r\u0026#39;key\u0026#39;: \u0026#39;Location\u0026#39;,\r\u0026#39;value\u0026#39;: \u0026#39;/uri-redirect.html\u0026#39;\r}]\r}\r}\rreturn response\relse:\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request Ở đoạn code này được dùng như một AWS CloudFront function. Nó phục vụ cho CloudFront event handler và implement logic cho URL redirection dựa vào URI được request. Function lambda_handler là entry point của Lambda function, nó gồm 2 parameters là event và context. Function này extract URI được request từ CloudFront event. Nếu request URI là /uri-main.html, code sẽ trả về một response với status code 301 và location header được set là /uri-redirect.html. Nếu URI không phải là /uri-main.html, code sẽ trả về request object.\nTiếp theo, click vào nút Deploy để code của lambda function của chúng ta được commit. Khi code của chúng ta được deploy thành công, chúng ta sẽ publish version mới cho lambda này. Click vào nút Actions ở góc bên phải, chúng ta chọn Publish new version. Chúng ta nhập edge-uri-redirect-v1 cho phần Version description và click vào nút Publish.\nStep 3: Kết hợp Lambda Function với CloudFront Behavior Quay trở lại lambda function console và mở function edge-uri-redirect.\nClick vào + Add trigger\nỞ trang Trigger configuration, chúng ta chọn CloudFront cho phần source. Sau đó click vào Deploy on Lambda@Edge. Có một cửa số mới mở ra, ở phần Distribution, chúng ta chọn distribution được tạo từ CloudFormation template. Phần Cache behavior, chúng ta chọn /uri-main.html. Ở phần CloudFront event, chọn Origin request. Đánh dấu vào ô Confirm deploy to Lambda@Edge và click vào nút Deploy. Step 4: Set up client cho testing Để test redirect cụ thể, chúng ta sẽ cần một client để chạy curl commands. Cách dễ dàng đó là tạo CloudShell Environments. CloudShell là một shell có sẵn trong AWS console và chúng ta có thể chạy những Linux command từ nó. Đi đến CloudShell Console và chờ đến khi terminal sẵn sàng để dùng.\nNếu CloudShell không hoạt động thì nếu bạn đang thực hành bài workshop này ở Linux/MacOS client thì hai hệ điều hành này đã có sẵn curl và bạn chỉ cần chạy command ở client đó. Nếu bạn đang thực hành trên Windows thì hãy tận dùng online curl tools như cái này. Có thể chạy EC2 instance hoặc Cloud9 IDE từ AWS COnsole để chạy commands.\nStep 5: Test redirect configuration Đi đến CloudShell Console.\nTrong phần test, chúng ta sẽ chạy câu lệnh curl để gửi http request đối với distrubtion của chúng ta, để làm như vậy, chúng ta cần copy Distribution domain name từ CloudFront console nơi chúng ta có thể tìm thấy.\nKhi đã tìm thấy distribution domain name, copy câu lệnh sau và thay thế domain name của chúng ta vào.\ncurl -v -o /dev/null https://\u0026lt;YOUR-DISTRIBUTION-DOMAIN-NAME\u0026gt;/uri-main.html Sau khi build câu lệnh trên từ cloudshell, chúng ta sẽ thấy kết quả như dưới đây. Chúng ta có thể thấy ở kết quả trên, request này nhận response HTTP 301, biểu thị redirect và Location header là URI nơi mà client được redirect đến.\nBây giờ, chúng ta chạy lại cùng câu lệnh trên. Và xem sự khác biệt. Sự khác biệt ở lần chạy câu lệnh này lại là giá trị của X-Cache header. Request bây giờ nhận response được redirect và đã được cache từ lần chạy câu lệnh trước đó. Có nghĩa là Lambda@edge của chúng ta không cần trigger lại, tiết kiệm thời gian và chi phí.\nChúng ta đã deploy thành công redirect đầu tiên bằng Lambda@Edge và đã test xong. Bây giờ chúng ta di chuyển sang trường hợp tiếp theo.\n"
},
{
	"uri": "/vi/3-cache/3.2-geored/",
	"title": "Geo Location Redirects",
	"tags": [],
	"description": "",
	"content": "Trường hợp này thường được dùng để redirect viewer đến country page của website của chúng ta. Ở sơ đồ dưới đây, chúng ta có thể thấy cấu trúc được build cho phần này.\nStep 1: Tạo CloudFront Cache policy để chuyển tiếp country header: Để có thể Redirect user dựa vào country location. Chúng ta cần đảm bảo rằng Contry Headeer liên kết với Lambda@Edge function. Để làm được điều này, chúng ta cần tạo Cache Policy nơi header được thêm vào cache key.\nĐến trang CloudFront Cache Policies console.\nỞ mục Custom Policies, click vào nút Create cache policy.\nỞ trang Create cache policy, đặt tên cho nó là edge-redirect-cache-policy. Ở phần Cache key settings, mở rộng phần Headers ra và chọn Include the following headers. Ở phần Add header, chúng ta tìm kiếm CloudFront-Viewer-Country và chọn nó. Những mục khác chúng ta để mặc định và click vào nút Create. Step 2: Tạo Lambda@Edge function và publish new version Ở bước này, chúng ta sẽ làm như ở phần trước, tạo Lambda function với tên edge-geo-redirect, Runtime là Python 3.9 và deploy nó. Sau đó, chúng ta cần publish new version của Lambda function vừa tạo.\nCode source của Lambda function này là:\nimport json\rdef lambda_handler(event, context):\r#Let\u0026#39;s first get the Country Code from the Request coming in\rget_country_viewer_header = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;headers\u0026#39;][\u0026#39;cloudfront-viewer-country\u0026#39;]\rdefine_country = get_country_viewer_header[0][\u0026#39;value\u0026#39;]\r#Now let\u0026#39;s define which country that is and create our redirected response\rif (define_country == \u0026#39;US\u0026#39;):\rresponse = {\r\u0026#39;status\u0026#39;: \u0026#39;301\u0026#39;,\r\u0026#39;statusDescription\u0026#39;: \u0026#39;Permanent Redirect\u0026#39;,\r\u0026#39;headers\u0026#39;: {\r\u0026#39;location\u0026#39;: [{\r\u0026#39;key\u0026#39;: \u0026#39;Location\u0026#39;,\r\u0026#39;value\u0026#39;: \u0026#39;/en-us.html\u0026#39;\r}]\r}\r}\r#The response above has been created and a response will be sent to the viewer to redirect it to the /en-us.html\rreturn response\relse:\r#if the country has not been identified then move on with the request\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request Step 3: Tạo CloudFront behavior cho trường hợp này Bây giờ Lambda function vừa được tạo và chúng ta phải assign nó cho một Cache Behavior trong CloudFront.\nĐi đến CloudFront console. Các bạn sẽ thấy Distribution được tạo ra bởi CloudFormation template, nó sẽ được xác định bởi Edge Redirect Workshop Distribution như ở mục Description.\nChọn Distribution đó sau đó chọn vào mục Behaviors.\nClick vào nút Create Behavior.\nỞ mục Path pattern, chúng ta nhập /geo.html. Ở dưới là phần Origin and origin groups, chúng ta chọn myS3Origin. Ở phần Viewer protocol policy, chúng ta chọn Redirect HTTP to HTTPS. Ở mục Cache key and origin requests, chúng ta chọn Cache policy and origin request policy, tiếp theo mở rộng mục Cache policy, chúng ta chọn policy vừa tạo ở bước trên edge-redirect-cache-policy. Những mục còn lại chúng ta sẽ để mặc định và click vào nút Create behavior ở cuối trang.\nStep 4: Kết hợp Lambda Function với CloudFront Behavior Chúng ta làm như ở trường hợp URI based Redirects ở trên, chúng ta sẽ kết hợp Lambda function edge-geo-redirect với CloudFront Behavior vừa tạo ở trên.\nStep 5: Set up clients cho testing Chúng ta sẽ cần một client để chạy curl commands. Cách dễ dàng đó là tạo CloudShell Environments. CloudShell là một shell có sẵn trong AWS console và chúng ta có thể chạy những Linux command từ nó. Đi đến CloudShell Console và chờ đến khi terminal sẵn sàng để dùng.\nNếu CloudShell không hoạt động thì nếu bạn đang thực hành bài workshop này ở Linux/MacOS client thì hai hệ điều hành này đã có sẵn curl và bạn chỉ cần chạy command ở client đó. Nếu bạn đang thực hành trên Windows thì hãy tận dùng online curl tools như cái này. Có thể chạy EC2 instance hoặc Cloud9 IDE từ AWS COnsole để chạy commands.\nStep 6: Test redirect configuration Đi đến CloudShell Console ở AWS Region us-east-1.\nTrong phần test, chúng ta sẽ chạy câu lệnh curl để gửi http request đối với distribution của chúng ta, để làm như vậy, chúng ta cần copy Distribution domain name từ CloudFront console nơi chúng ta có thể tìm thấy.\nKhi đã tìm thấy distribution domain name, copy câu lệnh sau và thay thế domain name của chúng ta vào.\ncurl -v -o /dev/null https://\u0026lt;YOUR-DISTRIBUTION-DOMAIN-NAME\u0026gt;/geo.html Sau khi build câu lệnh trên từ cloudshell, chúng ta sẽ thấy kết quả như dưới đây. \u0026lt; HTTP/1.1 301 Moved Permanently\r\u0026lt; Content-Length: 0\r\u0026lt; Connection: keep-alive\r\u0026lt; Server: CloudFront\r\u0026lt; Location: /en-us.html\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 6fbeae74487f866b555dc44d03fcc2a6.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: MIA3-P3\r\u0026lt; X-Amz-Cf-Id: VRNhLpCaNiZ08Fw5f2eMtWn8KfHnkPp3qp4kQeft3CVfEjo6kXIEWQ== Hãy chạy lại câu lệnh trên một lần nữa ở AWS Region us-east-1. Chúng ta sẽ thấy response khác nhau. \u0026lt; HTTP/1.1 301 Moved Permanently\r\u0026lt; Content-Length: 0\r\u0026lt; Connection: keep-alive\r\u0026lt; Server: CloudFront\r\u0026lt; Location: /en-us.html\r\u0026lt; X-Cache: Hit from cloudfront\r\u0026lt; Via: 1.1 e759cef9ef04dc6632a71818dfac3a76.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: MIA3-P3\r\u0026lt; X-Amz-Cf-Id: aOe3ADve7yDyHH_Iyb7MGMPAX8LWuTli79qf-nFl8rT40-VxPb_Zeg==\r\u0026lt; Age: 158 Chỉ có sự khác biệt ở đây là X-Cache response header. Chúng ta sẽ thấy Hit from cloudfront vì ở response đầu tiên sau khi request, nó đã được cache ở CloudFront nên request thứ hai sẽ không cần phải đi qua tất cả function thay vào đó nó sẽ chỉ được hoạt đồng từ cached content, điều này cung cấp hiệu suất tốt hơn và cũng giúp tiết kiệm chi phí vì function không cần trigger lần nữa.\nBây giờ, quay trở lại shell console và chạy cùng câu lệnh trên ở AWS Region eu-west-1. Bây giờ response của chúng ta sẽ không phải là HTTP 301 mà là HTTP 200 OK như dưới đây. \u0026lt; HTTP/1.1 200 OK\r\u0026lt; Content-Type: text/html\r\u0026lt; Content-Length: 98\r\u0026lt; Connection: keep-alive\r\u0026lt; ETag: \u0026#34;be3c901839ae019e0c58908e45f5ab45\u0026#34;\r\u0026lt; Accept-Ranges: bytes\r\u0026lt; Server: AmazonS3\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 9bbdfc2323989883f386114cc53fdbd0.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: MIA3-P3\r\u0026lt; X-Amz-Cf-Id: 2UlANwUbwF5Mv1V-XKWcYWKrTzIJZh2asxxw_xOK7aahkVP6TS6tRg==\r\u0026lt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;Not our US page\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;Not our US page\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; Response HTTP 200 OK của request này nghĩa là nó không được redirected và thay vào đó, resouce được request đã được CloudFront cung cấp.\nVậy là chúng ta đã deploy thành công redirect logic sử dụng Lambda@Edge và đã test xong. Trường hợp này có thể mở rộng ra phức tạp hơn, xác định không chỉ ở Contry mà còn cả các vị trí địa lí khác như States, Cities, postal codes, time zone. Tham khảo tài liệu này để tìm hiểu thêm về tất cả header location có thể có trong CloudFront.\n"
},
{
	"uri": "/vi/3-cache/3.3-devicered/",
	"title": "Device Redirects",
	"tags": [],
	"description": "",
	"content": "Trường hợp này được sử dụng để redirect viewer đến proper page của website dựa trên loại thiết bị gửi request đó. Sơ đồ sau đây cho thấy kiến trúc và các requested steps mà chúng ta sẽ làm trong phần này.\nStep 1: Tạo CloudFront Cache policy để chuyển tiếp device type header: Để có thể Redirect user dựa vào device type, CloudFront headers xác định device type của user sẽ liên kết đến Lambda@Edge function. Để làm được cái đó, bạn sẽ cần tạo Cache Policy trong đó header được thêm vào cache key. Trong bài workshop này, bạn sẽ sử dụng CloudFront-Is-Mobile-Viewer những cũng có sẵn những headers khác.\nĐến trang CloudFront Policies console. Chúng ta làm tương tự như phần Geo Location Redirects ở trên, chúng ta tạo một Cache Policy có tên là device-redirect-cache-policy. Và ở Headers của phần Cache key settings, chúng ta tìm kiến và chọn CloudFront-Is-Mobile-Viewer. Cuối cùng, chúng ta click vào nút Create.\nStep 2: Tạo Lambda@Edge function và publish new version Ở bước này, chúng ta sẽ làm như ở phần trước, tạo Lambda function với tên edge-device-redirect, Runtime là Python 3.9 và deploy nó. Sau đó, chúng ta cần publish new version của Lambda function vừa tạo.\nCode source của Lambda function này là:\nimport json\rdef lambda_handler(event, context):\rprint(event)\r#Let\u0026#39;s first get the Device Type from the Request coming in\rget_device_viewer_header = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;headers\u0026#39;][\u0026#39;cloudfront-is-mobile-viewer\u0026#39;]\rdefine_device_type = get_device_viewer_header[0][\u0026#39;value\u0026#39;]\rprint(define_device_type)\r#Now let\u0026#39;s see if this device is a mobile viewer or not and create the redirected response based on that\rif (define_device_type == \u0026#39;true\u0026#39;):\rresponse = {\r\u0026#39;status\u0026#39;: \u0026#39;301\u0026#39;,\r\u0026#39;statusDescription\u0026#39;: \u0026#39;Permanent Redirect\u0026#39;,\r\u0026#39;headers\u0026#39;: {\r\u0026#39;location\u0026#39;: [{\r\u0026#39;key\u0026#39;: \u0026#39;Location\u0026#39;,\r\u0026#39;value\u0026#39;: \u0026#39;/mobile.html\u0026#39;\r}]\r}\r}\r#The response above has been created and a response will be sent to the viewer to redirect it the right device page\rreturn response\relse:\r#if the device is not mobile, then move along with the request as is.\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request Step 3: Tạo CloudFront behavior cho trường hợp này Bây giờ Lambda function vừa được tạo và chúng ta phải assign nó cho một Cache Behavior trong CloudFront. Chúng ta làm như phần Geo Location Redirects ở trên. Với Path Pattern, chúng ta nhập /device.html và hãy nhớ chọn Cache policy là device-redirect-cache-policy vừa được tạo ở trên.\nStep 4: Kết hợp Lambda Function với CloudFront Behavior Chúng ta làm như ở phần Geo Location Redirects ở trên, chúng ta sẽ kết hợp Lambda function edge-device-redirect với CloudFront Behavior vừa tạo ở trên.\nStep 5: Set up clients cho testing Chúng ta sẽ cần một client để chạy curl commands. Cách dễ dàng đó là tạo CloudShell Environments. CloudShell là một shell có sẵn trong AWS console và chúng ta có thể chạy những Linux command từ nó. Đi đến CloudShell Console và chờ đến khi terminal sẵn sàng để dùng.\nNếu CloudShell không hoạt động thì nếu bạn đang thực hành bài workshop này ở Linux/MacOS client thì hai hệ điều hành này đã có sẵn curl và bạn chỉ cần chạy command ở client đó. Nếu bạn đang thực hành trên Windows thì hãy tận dùng online curl tools như cái này. Có thể chạy EC2 instance hoặc Cloud9 IDE từ AWS COnsole để chạy commands.\nStep 6: Test redirect configuration Đi đến CloudShell Console.\nTrong phần test, chúng ta sẽ chạy câu lệnh curl để gửi http request đối với distribution của chúng ta, để làm như vậy, chúng ta cần copy Distribution domain name từ CloudFront console nơi chúng ta có thể tìm thấy.\nKhi đã tìm thấy distribution domain name, copy câu lệnh sau và thay thế domain name của chúng ta vào.\ncurl -v -o /dev/null https://\u0026lt;YOUR-DISTRIBUTION-DOMAIN-NAME\u0026gt;/device.html Sau khi build câu lệnh trên từ cloudshell, chúng ta sẽ thấy kết quả như dưới đây. \u0026lt; HTTP/1.1 200 OK\r\u0026lt; Content-Type: text/html\r\u0026lt; Content-Length: 106\r\u0026lt; Connection: keep-alive\r\u0026lt; ETag: \u0026#34;73940ca66258e1bd0a623690f24fe324\u0026#34;\r\u0026lt; Accept-Ranges: bytes\r\u0026lt; Server: AmazonS3\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 2f66aa06710fece8ed203ab0ea81eb56.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: IAD89-C3\r\u0026lt; X-Amz-Cf-Id: ChlZowW_za1QF6FVmDX2iTENoknUBJxoxpMNV6S28E37g0khLdnxwg==\r\u0026lt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;non-mobile URI Page\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;non-mobile URI Page\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; Request trên cho thấy response thường xuyên. Điều này xảy ra đơn giản là do device mà chúng ta gửi request không được Lambda@Edge function nhận dạng là mobile device và nó cho phép request diễn ra bình thường.\nHãy chạy lại câu lệnh dưới đây. curl -v https://d2lagt3tnycm19.cloudfront.net/device.html -A \u0026#34;Mozilla/5.0 (iPhone; CPU iPhone OS 6_1_3 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) CriOS/28.0.1500.12 Mobile/10B329 Safari/8536.25\u0026#34; Chúng ta sẽ thấy response khác nhau.\n\u0026lt; HTTP/1.1 301 Moved Permanently\r\u0026lt; Content-Length: 0\r\u0026lt; Connection: keep-alive\r\u0026lt; Server: CloudFront\r\u0026lt; Location: /mobile.html\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 a4cae74c829bc214e4183c38164a2c0a.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: IAD89-C3\r\u0026lt; X-Amz-Cf-Id: sQ0_5pUMkOAJOBJUiTdDmEKGaq7ExMDotLmPsi-17WouwqcJBu7mNA==\r\u0026lt; Response ở đây hiện là HTTP 301, biểu thị redirect. Điều này xảy ra vì User-Agent theo request xác định là một mobile device, Lambda@Edge của chúng ta nắm bắt được điều đó và trả lời với một redirect.\nBây giờ, chạy câu lệnh như ở mục 4, chúng ta sẽ thấy sự khác biệt. \u0026lt; HTTP/1.1 301 Moved Permanently\r\u0026lt; Content-Length: 0\r\u0026lt; Connection: keep-alive\r\u0026lt; Server: CloudFront\r\u0026lt; Location: /mobile.html\r\u0026lt; X-Cache: Hit from cloudfront\r\u0026lt; Via: 1.1 38ecebcaa39c8742da2b6336935bb446.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: IAD89-C3\r\u0026lt; X-Amz-Cf-Id: 97bOlPobmuIto-LcDA5AbPprf6oXSniK4pq16RRpZSjVPVSb8HUr4Q==\r\u0026lt; Age: 133 Sự khác biệt chính ở đây lại là ở X-Cache header có giá trị là Hit from cloudfront, nghĩa là function này không cần chạy lại vì request đã được cache.\nVậy là chúng ta đã deploy thành công redirect logic sử dụng Lambda@Edge và đã test xong. Trường hợp này có thể mở rộng ra phức tạp hơn, xác định không chỉ là mobile device mà còn là cả Android và IOS clients, xác định SmartTVs và Tablet cũng có thể thực hiện được. Tham khảo tài liệu này để tìm hiểu thêm về tất cả header location có thể có trong CloudFront.\n"
},
{
	"uri": "/vi/3-cache/",
	"title": "Trường hợp cho Cacheable",
	"tags": [],
	"description": "",
	"content": "Xử lí Redirects bằng Lambda@Edge Trong phần này, chúng ta sẽ đề cập đến trường hợp có thể được cached. Lý tưởng nhất là các trường hợp này sẽ được xử lí bằng cách sử dụng Lambda@Edge.\nNhư đã nhắc đến trong phần Edge Compute Introduction, có nhiều triggers có sẵn cho Lambda@Edge, các trường hợp sẽ được giải quyết bằng cách sử dụng Origin facing event triggers.\nLambda@Edge Functions đang sử dụng Origin facing triggers sẽ được trigger sau khi request được đánh evaluate ở CloudFront Caching Layers, do đó, nếu có một response đã được cache thì một response sẽ được back lại viewer, tiết kiệm function invocations. Điều này không chỉ tăng tốc độ phản hồi mà còn giúp giảm chi phí redirects của chúng ta vì Lambda sẽ chỉ được kích hoặc nếu không có response nào được cached.\nNội dung Khai báo Table trong DynamoDB Tạo Lambda function "
},
{
	"uri": "/vi/4-terminate/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "CloudFormation Chúng ta vào CloudFormation Console Chúng ta sẽ thấy stack tên là edge-redirect-workshop được tạo từ CloudFormation template. Chúng ta chọn stack đó và click vào nút Delete ở trên cùng bên phải. Chờ khoảng vài phút chúng ta đã xóa thành công CloudFormation cùng những tài nguyên được tạo ra bởi nó trong lúc chúng ta bắt đầu workshop.\nLambda Function Chúng ta vào Lambda Console Chúng ta sẽ thấy có tất cả Lambda Function được tạo ra trong workshopp này. Tick vào tất cả function sau đó bấm vào nút Actions ở trên cùng bên phải và chọn Delete. Chúng ta nhập delete vào ô Confirm và cuối cùng là nhấn nút Delete để xóa. Vậy là chúng ta đã xóa thành công tất cả những Lambda Function được tạo ra trong workshop này.\nNếu các bạn nhận được cảnh báo Deleting Lambda@Edge functions and replicas trông lúc xóa Lambda Function thì hãy xem ở tài liệu này và làm theo để xóa thành công.\nVậy là chúng ta đã thực hiện thành công bài workshop này. Cảm ơn các bạn đã tham gia.\n"
},
{
	"uri": "/vi/3-cache/3.4-urirew/",
	"title": "URI based Rewrites",
	"tags": [],
	"description": "",
	"content": "Đây là một technique không liên quan đến việc redirect client browser đến một URL hoàn toàn mới. Tuy nhiên, browser sẽ tiếp tục nhận ra URI mà nó đã request, nhưng thay vì CloudFront truy xuất nó từ cùng một URI tại Original, n ó sẽ lấy nội dung từ một đường dẫn khác. Ví dụ: giả sử một browser đã gửi request tới resource www.example.com/uri-rewrite.html, nhưng bạn muốn lấy nội dung từ một đường dẫn cho backend khác hoặc thậm chí là một Orgin khác mà viewer không biết về cái này. Sau đó, bạn sẽ sử dụng Lambda@Edge function hoặc CloudFront function để làm URI rewrite và thực sự truy cập vào Origin để request một URI chẳng hạn như www.example.com/rewrite.html\nĐối với trường hợp này, chúng ta sẽ sử dụng Default Behavior từ CloudFront và sẽ không sử dụng bất kỳ header cụ thể nào để dựa trên logic function của chúng ta, vì vậy bạn cũng không cần tạo cache policy mới. Tuy nhiên, những thứ đó rất có thể được sử dụng để tạo các tình huống phức tạp hơn, trong đó thay vì redirect, chúng ta có thể rewrite URI ở backend. Ở các ví dụ trước của chúng ta trong workshop này, chúng ta có thể phát hiện location hoặc loại device của viewer và lấy một URI khác từ backend thay vì redirect user. Hình ảnh sau đây mô tả cấu trúc về những gì sẽ được xây dựng trong bài workshop này:\nStep 1: Tạo CloudFront Behavior: Xem lại ở ví dụ URI based Redirects, chúng ta tạo Behavior với Path Pattern là /uri-rewrite.html và ở mục Origin and origin group, chúng ta chọn myS3Origin.\nStep 2: Tạo Lambda@Edge function và publish new version Ở bước này, chúng ta sẽ làm như ở phần trước, tạo Lambda function với tên edge-uri-rewrite, Runtime là Python 3.9 và deploy nó. Sau đó, chúng ta cần publish new version của Lambda function vừa tạo.\nCode source của Lambda function này là:\nimport json\rdef lambda_handler(event, context):\r#let\u0026#39;s first extract the URI from the request\rget_uri = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;uri\u0026#39;]\r#let\u0026#39;s check what is the URI and decide if the URI sent to the Origin should be modified\rif (get_uri == \u0026#39;/uri-rewrite.html\u0026#39;):\revent[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;][\u0026#39;uri\u0026#39;] = \u0026#39;/rewrite.html\u0026#39;\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request\r#if the uri should not be modified then just continue with the request as is\relse:\rrequest = event[\u0026#39;Records\u0026#39;][0][\u0026#39;cf\u0026#39;][\u0026#39;request\u0026#39;]\rreturn request Step 3: Kết hợp Lambda Function với CloudFront Behavior Chúng ta làm như ở phần Geo Location Redirects ở trên, chúng ta sẽ kết hợp Lambda function edge-uri-rewrite với CloudFront Behavior vừa tạo ở trên.\nStep 5: Set up clients cho testing Chúng ta sẽ cần một client để chạy curl commands. Cách dễ dàng đó là tạo CloudShell Environments. CloudShell là một shell có sẵn trong AWS console và chúng ta có thể chạy những Linux command từ nó. Đi đến CloudShell Console và chờ đến khi terminal sẵn sàng để dùng.\nNếu CloudShell không hoạt động thì nếu bạn đang thực hành bài workshop này ở Linux/MacOS client thì hai hệ điều hành này đã có sẵn curl và bạn chỉ cần chạy command ở client đó. Nếu bạn đang thực hành trên Windows thì hãy tận dùng online curl tools như cái này. Có thể chạy EC2 instance hoặc Cloud9 IDE từ AWS COnsole để chạy commands.\nStep 6: Test redirect configuration Đi đến CloudShell Console.\nTrong phần test, chúng ta sẽ chạy câu lệnh curl để gửi http request đối với distribution của chúng ta, để làm như vậy, chúng ta cần copy Distribution domain name từ CloudFront console nơi chúng ta có thể tìm thấy.\nKhi đã tìm thấy distribution domain name, copy câu lệnh sau và thay thế domain name của chúng ta vào.\ncurl -v -o /dev/null https://\u0026lt;YOUR-DISTRIBUTION-DOMAIN-NAME\u0026gt;/uri-rewrite.html Sau khi build câu lệnh trên từ cloudshell, chúng ta sẽ thấy kết quả như dưới đây. \u0026lt; HTTP/1.1 200 OK\r\u0026lt; Content-Type: text/html\r\u0026lt; Content-Length: 92\r\u0026lt; Connection: keep-alive\r\u0026lt; ETag: \u0026#34;a1764624bd34afb8e52157f114ef6db1\u0026#34;\r\u0026lt; Accept-Ranges: bytes\r\u0026lt; Server: AmazonS3\r\u0026lt; X-Cache: Miss from cloudfront\r\u0026lt; Via: 1.1 3cf1bfec064e2e01f071e8051a22d830.cloudfront.net (CloudFront)\r\u0026lt; X-Amz-Cf-Pop: ATL56-C1\r\u0026lt; X-Amz-Cf-Id: HeF7XzxKoVyNxUKAAnP0t8bCzpwbN-pyex3mRMbqcH-mQOT5V3yjAw==\r\u0026lt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;Rewrite Page\u0026lt;/h1\u0026gt;\r\u0026lt;p\u0026gt;Rewrite Page\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt; Request trên cho thấy direct response đối với request của chúng ta là HTTP 200 OK, nghĩa là đây không phải là redirect, thay vào đó nội dung đã được cung cấp, tuy nhiên trong trang này, bạn có thể thấy HTML được tạo cho biết đây là nội dung rewrite thay vì nội dung chính.\nVậy là chúng ta đã deploy thành công trường hợp URI rewrite. Trường hợp này có thể mở rộng để xử lí logic phức tạp hơn cũng như thậm chí truy xuất nội dụng từ các Origin khác nhau nếu được request. Trường hợp này cũng có thể được thực hiện bằng cách sử dụng các function của CloudFront nếu trường hợp của chúng tôi yêu tất cả request phải được evaluate và rewrite.\n"
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]